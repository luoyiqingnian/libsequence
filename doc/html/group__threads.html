<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsequence: Parallel computing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsequence
   &#160;<span id="projectnumber">1.9.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__threads.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Parallel computing</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classes &amp; functions related to using parallelized algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga744123dc67a21645e9408ad930f007d3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; tbb::task_scheduler_init &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#ga744123dc67a21645e9408ad930f007d3">Sequence::init_tbb</a> (int nthreads=tbb::task_scheduler_init::automatic)</td></tr>
<tr class="memdesc:ga744123dc67a21645e9408ad930f007d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique_ptr to a tbb::task_scheduler_init.  <a href="group__threads.html#ga744123dc67a21645e9408ad930f007d3">More...</a><br /></td></tr>
<tr class="separator:ga744123dc67a21645e9408ad930f007d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae62947ef6ee60f62b3f43096aecaec26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#gae62947ef6ee60f62b3f43096aecaec26">Sequence::PolySNP::DepaulisVeuilleStatistics</a> (void) const</td></tr>
<tr class="separator:gae62947ef6ee60f62b3f43096aecaec26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2d944ca3bf2a6a8a9c10a18306082bb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structSequence_1_1PairwiseLDstats.html">PairwiseLDstats</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threads.html#gaa2d944ca3bf2a6a8a9c10a18306082bb">Sequence::PolySNP::Disequilibrium</a> (const unsigned &amp;mincount=1, const double &amp;max_marker_distance=std::numeric_limits&lt; double &gt;::max()) const</td></tr>
<tr class="separator:gaa2d944ca3bf2a6a8a9c10a18306082bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Classes &amp; functions related to using parallelized algorithms. </p>
<p>libsequence uses the Intel TBB library for parallel processing. With TBB, the number of threads is determined automatically. The default/automatic behavior can be changed by creating an instance of a tbb::task_scheduler_init object:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tbb/task_scheduler_init.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//restrict parallelism to max_threads</span></div><div class="line">tbb::task_scheduler_init init(max_threads);</div></div><!-- fragment --><p>Doing the above requires that your program further link to TBB, via -ltbb. When using the default scheme (e.g., your program does not manage its own task_scheduler_init), you do not need to link to TBB, as libsequence itself is linked.</p>
<p>For cases where libsequence is used as a back-end for projects in other languages like R or Python, we provide <a class="el" href="group__threads.html#ga744123dc67a21645e9408ad930f007d3" title="Return a unique_ptr to a tbb::task_scheduler_init. ">Sequence::init_tbb</a> which returns a std::unique_ptr&lt;tbb::task_scheduler_init&gt;. This function can be wrapped, allowing control over threading as desired.</p>
<p>Unfortunately, Doxygen limits functions to belonging to a single group, making it difficult to auto-generate a list of parallelized functions. The following list of threaded functions in other groups is manually maintained, and may thus be incomplete:</p>
<ul>
<li><a class="el" href="group__popgenanalysis.html#ga08bc910f7be7c6cd753fa93e2dd33c82">Sequence::nSL_t</a></li>
<li>Sequence::snSL</li>
<li><a class="el" href="structSequence_1_1GarudStats.html">Sequence::GarudStats</a></li>
<li><a class="el" href="namespaceSequence_1_1Recombination.html#a4d94f494d332f13638905822cb98bdc5" title="Calculate pairwise LD for a Sequence::PolyTable. ">Sequence::Recombination::Disequilibrium</a></li>
</ul>
<p>While there are lots of calculations that may be parallelized, not all will benefit. We have to test each function individually and make the determination. Fortunately, TBB allows us to do this in the implementation without changing the public interface, meaning we can take our time and slowly introduce more parallelism into the library. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae62947ef6ee60f62b3f43096aecaec26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae62947ef6ee60f62b3f43096aecaec26">&#9670;&nbsp;</a></span>DepaulisVeuilleStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::PolySNP::DepaulisVeuilleStatistics </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the number of haplotypes in the sample, and haplotype diversity. Unlike Depaulis and Veuille's original paper, this routine uses an unbiased calculation of haplotype diversity (i.e. divide by n choose 2). <br />
To check if two sequences are unique, Sequence::Comparisons::Different is used, which does not allow missing data to result in 2 sequences being considered different (as they would be if you simply used the std::string comparison operators == or !=) </p>

<p class="definition">Definition at line <a class="el" href="PolySNP_8cc_source.html#l01050">1050</a> of file <a class="el" href="PolySNP_8cc_source.html">PolySNP.cc</a>.</p>

</div>
</div>
<a id="gaa2d944ca3bf2a6a8a9c10a18306082bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2d944ca3bf2a6a8a9c10a18306082bb">&#9670;&nbsp;</a></span>Disequilibrium()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structSequence_1_1PairwiseLDstats.html">PairwiseLDstats</a> &gt; Sequence::PolySNP::Disequilibrium </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>mincount</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>max_marker_distance</em> = <code>std::numeric_limits&lt;double&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A vector of statistics related to LD and distance in the sample. An empty vector is returned if there are &lt; 2 polymorphic sites in the sample. See the documentation for <a class="el" href="namespaceSequence_1_1Recombination.html#a4d94f494d332f13638905822cb98bdc5" title="Calculate pairwise LD for a Sequence::PolyTable. ">Recombination::Disequilibrium</a> for a description of the return vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mincount</td><td>a frequency filter. A polymorphism must be present at least <em>mincount</em> times in the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For D and D', the 11 gamete is defined as follows: If no outgroup is present, it refers to the genotype of minor alleles at both sites. If there is an outgroup, it is based on the genotype of derived alleles at both sites. </dd></dl>

<p class="definition">Definition at line <a class="el" href="PolySNP_8cc_source.html#l01862">1862</a> of file <a class="el" href="PolySNP_8cc_source.html">PolySNP.cc</a>.</p>

</div>
</div>
<a id="ga744123dc67a21645e9408ad930f007d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga744123dc67a21645e9408ad930f007d3">&#9670;&nbsp;</a></span>init_tbb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; tbb::task_scheduler_init &gt; Sequence::init_tbb </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>tbb::task_scheduler_init::automatic</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a unique_ptr to a tbb::task_scheduler_init. </p>
<p>This exists mainly for libsequence-based extensions in other languages. This function is not necessary in a standalone program where you can rely on creating a tbb::task_scheduler_init on the stack.</p>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;tbb::task_scheduler_init&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="threading_8cc_source.html#l00006">6</a> of file <a class="el" href="threading_8cc_source.html">threading.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jul 12 2018 15:34:19 for libsequence by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>

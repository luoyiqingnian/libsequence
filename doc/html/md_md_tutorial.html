<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsequence: Tutorial/overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsequence
   &#160;<span id="projectnumber">1.9.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_md_tutorial.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial/overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#background">Background</a><ul><li class="level2"><a href="#streams">A quick note on streams</a></li>
</ul>
</li>
<li class="level1"><a href="#seq">Handling biological sequences.</a><ul><li class="level2"><a href="#seqio">Reading and writing</a><ul><li class="level3"><a href="#seqgz">Gzipped files, etc.</a></li>
</ul>
</li>
<li class="level2"><a href="#manip">Manipulating a sequence</a></li>
</ul>
</li>
<li class="level1"><a href="#alphabet">Testing for correct character sets</a></li>
<li class="level1"><a href="#alignments">Input and output of DNA sequence alignments</a></li>
<li class="level1"><a href="#polymorphism_tables">Polymorphism tables</a><ul><li class="level2"><a href="#polytable_terms">Definitions of terms</a></li>
<li class="level2"><a href="#polytable">Sequence::PolyTable in detail</a><ul><li class="level3"><a href="#polytables">The inheritance hierarchy.</a></li>
<li class="level3"><a href="#customptables">Handling custom input formats</a></li>
<li class="level3"><a href="#polytable_construct">Constructing PolyTables</a><ul><li class="level4"><a href="#polytable_read">From streams</a></li>
</ul>
</li>
<li class="level3"><a href="#polytable_move">Using move construction</a></li>
<li class="level3"><a href="#polytable_access">Accessing the data</a></li>
<li class="level3"><a href="#polytable_manip">Manipulating PolyTables</a></li>
<li class="level3"><a href="#polytable_manip_builtin">Methods provided</a><ul><li class="level4"><a href="#polytable_idiot">Don&#39;t be this guy</a></li>
</ul>
</li>
<li class="level3"><a href="#polytable_csi">Iterating over sites directly</a></li>
</ul>
</li>
<li class="level2"><a href="#ptable_detail">Sequence::polySiteVector in detail</a></li>
<li class="level2"><a href="#polytable_ptable">The relationship between PolyTable and polySiteVector</a></li>
</ul>
</li>
<li class="level1"><a href="#summstats">Summary statistics</a><ul><li class="level2"><a href="#classic">Standard summary statistics</a></li>
<li class="level2"><a href="#classic_fst">FST</a></li>
<li class="level2"><a href="#hka">The HKA test</a></li>
<li class="level2"><a href="#stat_future">The future</a></li>
</ul>
</li>
<li class="level1"><a href="#coalsim">Coalescent simulation</a></li>
<li class="level1"><a href="#hts_tut">High-throughput sequencing</a><ul><li class="level2"><a href="#sam">SAM records</a></li>
<li class="level2"><a href="#samflags">SAM flags and bit fields</a></li>
<li class="level2"><a href="#bam">BAM files</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The citation for the library is <a class="el" href="citelist.html#CITEREF_Thornton:2003vz">[4]</a></p>
<p>This document is a rapid-fire overview of library features.</p>
<h1><a class="anchor" id="background"></a>
Background</h1>
<p>I assume a working familiarity with:</p>
<ul>
<li>C++ and "C++11"</li>
</ul>
<p>The code snippets below all use C++11 language features (initialization lists, lambda expressions, etc.). Using GCC/clang, you would need to compile with -std=c++11. Note, however, that none of the snippets below will actually compile, as they are not complete C++ programs.</p>
<h2><a class="anchor" id="streams"></a>
A quick note on streams</h2>
<p>In C++, input from streams are handled via operator&gt;&gt; and operator&lt;&lt;. libsequence defines many of these operators for its types (see <a class="el" href="group__operators.html">Operator overloads</a>). These operators are overloaded for uncompressed ASCII streams (aka plain-text files and buffers). However, all of these operators are compatible with well-designed compressed-file streams, too. Programmers using libsequence may use <a href="http://www.boost.org">boost</a>'s filtering_ostream libraries as replacements for &lt;fstream&gt; as they see fit.</p>
<h1><a class="anchor" id="seq"></a>
Handling biological sequences.</h1>
<p>A sequence is defined by the "pure virtual" class <a class="el" href="classSequence_1_1Seq.html" title="Abstract interface to sequence objects. ">Sequence::Seq</a>, which publicly inherits from std::pair&lt;std::string,std::string&gt;. The two members of the pair are the sequence name and the sequence itself, respectively.</p>
<p>A programmer may define new sequences via public inheritance from <a class="el" href="classSequence_1_1Seq.html" title="Abstract interface to sequence objects. ">Sequence::Seq</a>. The programmer must define the public member funtions Sequence::read and Sequence::print in order to make a valid class. See <a class="el" href="classSequence_1_1Fasta.html" title="FASTA sequence stream. ">Sequence::Fasta</a> and <a class="el" href="classSequence_1_1fastq.html">Sequence::fastq</a> for examples. These two functions (read/print) allow sequences to be read/written to/from C++ streams.</p>
<p><a class="el" href="classSequence_1_1Seq.html" title="Abstract interface to sequence objects. ">Sequence::Seq</a> defines several functions for data access and various biological operations (<a class="el" href="classSequence_1_1Seq.html#ac83a47f3bb7de9a0be61de360fccf623">Sequence::Seq::Revcom</a>, etc.).</p>
<h2><a class="anchor" id="seqio"></a>
Reading and writing</h2>
<p>During read operations, a sequence object may throw an exception of type Sequence::badFormat if the data stream is not in the correct format. The built-int types (<a class="el" href="classSequence_1_1Fasta.html" title="FASTA sequence stream. ">Sequence::Fasta</a> and <a class="el" href="classSequence_1_1fastq.html">Sequence::fastq</a>) do not throw on write (although the output stream type could if something bad happens with the stream itself, etc.).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Fasta_8hpp.html">Sequence/Fasta.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="classSequence_1_1Fasta.html">Sequence::Fasta</a> f;</div><div class="line"></div><div class="line">std::ifstream in(<span class="stringliteral">&quot;filename.fasta&quot;</span>)</div><div class="line"></div><div class="line"><span class="keyword">try</span> {</div><div class="line">in &gt;&gt; f &gt;&gt; std::wd;</div><div class="line">} <span class="keywordflow">catch</span> (Sequence::badFormat &amp; __b)</div><div class="line">{</div><div class="line">std::cerr &lt;&lt; __b &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">exit(1);</div><div class="line">}</div></div><!-- fragment --><p>A sequence may be written to an output stream using the usual C++ output operator &lt;&lt;.</p>
<h3><a class="anchor" id="seqgz"></a>
Gzipped files, etc.</h3>
<p>For reading/writing compressed files, see the <a href="http://www.boost.org">boost</a>'s filtering_ostream libraries. They have been tested, and "just work" with libsequence objects.</p>
<p>Note: at the time of this writing (and as per my latest testing) the boost libraries do not support opening compressed streams in append mode. If you need to append to files, then buffer output to a std::ostringstream and write the buffer to a gzFile using <a href="http://zlib.net">zlib</a> directly:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;zlib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line">std::ostringstream o;</div><div class="line"><span class="comment">//Fill o with stuff</span></div><div class="line"></div><div class="line">gzFile f = gzopen(<span class="stringliteral">&quot;file.gz&quot;</span>,<span class="stringliteral">&quot;a&quot;</span>);</div><div class="line"><span class="comment">//Write your data to the .gz file</span></div><div class="line">gzwrite(f,o.str().c_str(),o.str().size());</div><div class="line"><span class="comment">//Clear your buffer</span></div><div class="line">o.str(std::string());</div></div><!-- fragment --><h2><a class="anchor" id="manip"></a>
Manipulating a sequence</h2>
<p><a class="el" href="classSequence_1_1Seq.html" title="Abstract interface to sequence objects. ">Sequence::Seq</a> provides obvious member functions for element access and iteration. Further, because a sequence inherits from std::pair&lt;std::string,std::string&gt;, a library user may use any of std::string's member functions as well:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceSequence.html">Sequence</a> fasta f;</div><div class="line"><span class="comment">//This is the name, whose type is std::string</span></div><div class="line"><span class="keyword">auto</span> namelen = f.first.size();</div><div class="line"><span class="comment">//The sequence is also std::string:</span></div><div class="line"><span class="keyword">auto</span> seqlen = f.second.size();</div></div><!-- fragment --><p>You may also access the data in the sequence (but not the name!) using C++11 range-based for loops:</p>
<div class="fragment"><div class="line"><a class="code" href="classSequence_1_1Fasta.html">Sequence::Fasta</a> f(<span class="stringliteral">&quot;name&quot;</span>,<span class="stringliteral">&quot;TTT&quot;</span>);</div><div class="line"><span class="comment">//The for loop is equavalent to:</span></div><div class="line"><span class="comment">//for( auto &amp; c : f.second )</span></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span> &amp; c : f )</div><div class="line">{</div><div class="line">        c = <span class="charliteral">&#39;C&#39;</span>;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="alphabet"></a>
Testing for correct character sets</h1>
<p>The list of characters accepted as DNA is defined in the constant array <a class="el" href="group__Alphabets.html#ga790250a2ef0192d63a54b94ef646be32" title="Alphabet for DNA sequences Valid DNA characters. Upper-case only. Only - is accepted as gap character...">Sequence::dna_alphabet</a>, declared in <a class="el" href="SeqAlphabets_8hpp.html">Sequence/SeqAlphabets.hpp</a>. The type of <a class="el" href="group__Alphabets.html#ga790250a2ef0192d63a54b94ef646be32" title="Alphabet for DNA sequences Valid DNA characters. Upper-case only. Only - is accepted as gap character...">Sequence::dna_alphabet</a> is std::array&lt;const char,17&gt;, and may therefore be iterated over, etc., as per a normal std::array type.</p>
<p>The function <a class="el" href="group__Alphabets.html#ga04b131da5a173bc96dff2079b18e5ae6" title="test if character is part of Sequence::dna_alphabet ">Sequence::isDNA</a> accepts a single char as an argument and returns true if the argument is found in <a class="el" href="group__Alphabets.html#ga790250a2ef0192d63a54b94ef646be32" title="Alphabet for DNA sequences Valid DNA characters. Upper-case only. Only - is accepted as gap character...">Sequence::dna_alphabet</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Fasta_8hpp.html">Sequence/Fasta.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="SeqAlphabets_8hpp.html">Sequence/SeqAlphabets.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="classSequence_1_1Fasta.html">Sequence::Fasta</a> f = { <span class="stringliteral">&quot;name&quot;</span>,   <span class="stringliteral">&quot;ATGCZAGC&quot;</span> };  <span class="comment">//Z is a non-DNA character</span></div><div class="line"></div><div class="line"><span class="comment">//Find non-DNA characters:</span></div><div class="line"><span class="keyword">auto</span> itr = std::find_if( f.<a class="code" href="classSequence_1_1Seq.html#abd1fcbf6b32d4699ac98665b79164704">begin</a>(),f.<a class="code" href="classSequence_1_1Seq.html#a0c49ccc23f78c9d5f2dd8ea75f32e6eb">end</a>(),</div><div class="line">                            [](<span class="keyword">const</span> <span class="keywordtype">char</span> &amp; __ch) {</div><div class="line">                            <span class="keywordflow">return</span> !<a class="code" href="group__Alphabets.html#ga04b131da5a173bc96dff2079b18e5ae6">Sequence::isDNA</a>(__ch);</div><div class="line">                           } );</div><div class="line"></div><div class="line"><span class="comment">//Delete them from sequences:</span></div><div class="line">  f.second.erase( std::remove_if(f.<a class="code" href="classSequence_1_1Seq.html#abd1fcbf6b32d4699ac98665b79164704">begin</a>(),</div><div class="line">                                 f.<a class="code" href="classSequence_1_1Seq.html#a0c49ccc23f78c9d5f2dd8ea75f32e6eb">end</a>(),</div><div class="line">                                 [](<span class="keyword">const</span> <span class="keywordtype">char</span> &amp; __ch) {</div><div class="line">                                   <span class="keywordflow">return</span> !<a class="code" href="group__Alphabets.html#ga04b131da5a173bc96dff2079b18e5ae6">Sequence::isDNA</a>(__ch);</div><div class="line">                                 }), f.second.<a class="code" href="classSequence_1_1Seq.html#a0c49ccc23f78c9d5f2dd8ea75f32e6eb">end</a>() );</div></div><!-- fragment --><p>The above code block comes from the unit test file <a class="el" href="alphabets_8cc.html" title="Unit tests for Sequence/SeqAlphabets.hpp. ">alphabets.cc</a></p>
<h1><a class="anchor" id="alignments"></a>
Input and output of DNA sequence alignments</h1>
<p>libsequence contains support for I/O and processing of sequence alignments. The primary use for these functions and classes is to handle the sorts of data that one would collect for population genetic analysis based on Sanger resequencing data and/or phylogenetic analysis.</p>
<p>The relevant modules are:</p>
<ul>
<li><a class="el" href="classSequence_1_1AlignStream.html" title="Virtual interface to alignment streams. ">Sequence::AlignStream</a> is a template class abstracting the I/O for alignment data.</li>
<li>namespace <a class="el" href="namespaceSequence_1_1Alignment.html" title="Routines fundamental to aligned data. ">Sequence::Alignment</a></li>
</ul>
<p>Concrete examples of <a class="el" href="classSequence_1_1AlignStream.html" title="Virtual interface to alignment streams. ">Sequence::AlignStream</a> include:</p>
<ul>
<li><a class="el" href="classSequence_1_1ClustalW.html" title="ClustalW streams. ">Sequence::ClustalW</a></li>
<li><a class="el" href="classSequence_1_1phylipData.html">Sequence::phylipData</a></li>
</ul>
<p>Developers wishing to handle other input/output formats should study the implementation of those two classes.</p>
<p>As of the time of this writing (2014), these classes may be viewed as quaint. However, I still think that there is some value to them, and refer the reader to the following sources for usage examples:</p>
<ul>
<li>The <a href="http://github.com/molpopgen/analysis">analysis</a> package that I maintain</li>
<li>The unit test files <a class="el" href="AlignStreamTest_8cc.html" title="unit tests for Sequence::ClustalW and Sequence::phylipData ">AlignStreamTest.cc</a> and <a class="el" href="AlignmentTest_8cc.html" title="Unit tests for fxns in namespace Sequence::Alignment. ">AlignmentTest.cc</a>. These tests provide good coverage of relevant usage cases (and a few cases of user error, too).</li>
</ul>
<h1><a class="anchor" id="polymorphism_tables"></a>
Polymorphism tables</h1>
<p>Perhaps the most powerful part of libsequence is the efficient handling of tables of variable sites (polymorphism tables).</p>
<p>There are three basic types for the maninpulation of variation data:</p>
<ul>
<li><a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">Sequence::PolyTable</a> is a pure virtual base class for polymorphism tables. In essence, a PolyTable is a std::vector&lt;std::string&gt;, where the strings are the variable sites comprising the haplotypes in the sample. In addition to this vector of strings, a std::vector&lt;double&gt; stores the positions of the variable sites. This representation of variation data is the oldest in the library, several functions exist for processing these types.</li>
<li><a class="el" href="namespaceSequence.html#a08841c3bd3b0999a40dfdadbee4a6b0d">Sequence::polymorphicSite</a> is a typedef for std::pair&lt;double, std::string&gt;. The double represents the site position, and the string represents the state of each individual in the sample.</li>
<li><a class="el" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">Sequence::polySiteVector</a> is a typedef for std::vector&lt;Sequence::polymorphicSite&gt;. This type has existed for a while, and is a handy way to manipulate data in a SNP-centric way.</li>
</ul>
<p>The major difference between <a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">Sequence::PolyTable</a> and <a class="el" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">Sequence::polySiteVector</a> is how the data are stored internally. Iteration over a <a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">Sequence::PolyTable</a> iterates over <em>haplotypes</em>, whereas iteration through a polySiteVector moves across <em>variable sites</em>. These concepts will become more clear when we look at specific examples below.</p>
<h2><a class="anchor" id="polytable_terms"></a>
Definitions of terms</h2>
<p>Formally, the objects discussed in this section are agnostic with respect to ploidy. Further, I use the term <em>haplotype</em> here loosely. If the data that populate a PolyTable or polySiteVector come from sources such as X-chromosome sequences obtained from males, autosomal sequences from a highly-inbred <em>Drosophila</em> or <em>Arabidopsis</em>, or the output of some sort of haplotype phasing algorithm, then the haplotypes are indeed haplotypes (although, for the latter case, one should use the likeliehood of the haplotype inference as a weight on any results, if appropriate). However, if the input are diploid genotype data, then those data must be split into two strings for that individual (in the case of a PolyTable), which will require arbitrarily assigning the values for a heterozygote to each string. For such data, <b>it is user error to then apply any haplotype- or LD-based calculation to the data</b>.</p>
<p>The only allowed characters in these objects are the set A,G,C,T,N,.,-,0,1. The first five values should be obvious. The next two are the identity and gap characters, respectively. The 0 and 1 may be used in various ways, such as representing arbitrary states of biallelic data, ancestral vs. derived character states, minor/major alleles, or to represent more complex genotypes at a site. A programmer may check that data contain valid characters using functions declared in <a class="el" href="SeqAlphabets_8hpp.html">Sequence/SeqAlphabets.hpp</a>: <a class="el" href="structSequence_1_1ambiguousNucleotide.html" title="Tests if a character is in the set A,G,C,T. ">Sequence::ambiguousNucleotide</a> and <a class="el" href="structSequence_1_1invalidPolyChar.html" title="This functor can be used to determine if a range contains characters that the SNP analysis routines i...">Sequence::invalidPolyChar</a>.</p>
<h2><a class="anchor" id="polytable"></a>
Sequence::PolyTable in detail</h2>
<h3><a class="anchor" id="polytables"></a>
The inheritance hierarchy.</h3>
<p><a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">Sequence::PolyTable</a> is a pure virtual class that inherits publicly from objects in namespace std:</p>
<div class="fragment"><div class="line"><span class="comment">//The vector of doubles are the site positions.  The strings are the haplotypes</span></div><div class="line"><span class="keyword">class </span><a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a> : <span class="keyword">public</span> std::pair&lt;std::vector&lt;double&gt;, std::vector&lt;std::string&gt; &gt;</div><div class="line">{</div><div class="line">};</div></div><!-- fragment --><p>As with <a class="el" href="classSequence_1_1Seq.html" title="Abstract interface to sequence objects. ">Sequence::Seq</a>, there are two pure virtuals member functions, <a class="el" href="classSequence_1_1PolyTable.html#a27a62e9ee28d31f4b386c79a7af167a0">Sequence::PolyTable::read</a> and <a class="el" href="classSequence_1_1PolyTable.html#ab3750df4d791c24e87815a29fbac77f4">Sequence::PolyTable::print</a>. A valid class must publicly inherit from <a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">Sequence::PolyTable</a> and define these functions. The library defines the following three classes that publicly inherit from the base class:</p>
<ul>
<li><a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">Sequence::SimData</a> is intended to represent binary variation data in the format used by Dick Hudson's coalescent simulation program <a class="el" href="citelist.html#CITEREF_Hudson:2002vy">[2]</a>. This is the "standard" format used for simulating biallelic sites, and the character states have a very specific meaning: 0 = the ancestral state, 1 = the derived state. See the example program <a class="el" href="msstats_8cc_source.html">msstats.cc</a> for how to read these objects in from streams, and the documentation for the file <a class="el" href="SimDataIO_8hpp.html" title="Various I/O functions for Sequence::SimData. ">Sequence/SimDataIO.hpp</a> for how to read/write from gzipped streams, binary streams, etc.</li>
<li><a class="el" href="classSequence_1_1PolySites.html" title="Polymorphism tables for sequence data. ">Sequence::PolySites</a> This is a generic/catch-all class for nucleotide-based SNP data.</li>
<li><a class="el" href="classSequence_1_1SimpleSNP.html" title="SNP table data format. ">Sequence::SimpleSNP</a> This class handles the format used by the software described in <a href="http://www.genetics.org/content/159/4/1805.abstract">Hudson (2001)</a>.</li>
</ul>
<p>The examples below focus on <a class="el" href="classSequence_1_1PolySites.html" title="Polymorphism tables for sequence data. ">Sequence::PolySites</a>.</p>
<h3><a class="anchor" id="customptables"></a>
Handling custom input formats</h3>
<p>If a user requires reading in data from a custom input format (HapMap, VCF, etc.), take the following steps:</p>
<ul>
<li>Create a new class that publicly inherits from <a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">Sequence::PolyTable</a>. For example:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>myPT : <span class="keyword">public</span> <a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a></div><div class="line">{</div><div class="line">};</div></div><!-- fragment --><ul>
<li>Define the read and print member functions. See implementations of <a class="el" href="classSequence_1_1PolySites.html" title="Polymorphism tables for sequence data. ">Sequence::PolySites</a> and/or <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">Sequence::SimData</a> for inspiration. These functions make your class compatible with operator&gt;&gt; and operator&lt;&lt;, respectively. Ideally, your class would be compatible with std::istream_iterator&lt;myPT&gt; as well, but that is often a little harder to do.</li>
<li>Define move-constructors and move-assignment operators. If you only want to construct myPTs from other myPTs, then the compiler defaults will be fine. However, if you want to convert from any other type of PolyTable, then you must also define custom move-constructors and move-assigment operators:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>myPT : <span class="keyword">public</span> <a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a></div><div class="line">{</div><div class="line">        myPT( myPT &amp;&amp; ) = <span class="keywordflow">default</span>;</div><div class="line">        myPT( myPT &amp; ) = <span class="keywordflow">default</span>;</div><div class="line">        myPT( <a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a> &amp; ); <span class="comment">//you&#39;ll need to define this elsewhere</span></div><div class="line">        myPT &amp; <a class="code" href="classSequence_1_1PolyTable.html#a72dc7fa01ada9d692a6a702dd688e525">operator=</a>( myPT &amp; ) = <span class="keywordflow">default</span>;</div><div class="line">        myPT &amp; <a class="code" href="classSequence_1_1PolyTable.html#a72dc7fa01ada9d692a6a702dd688e525">operator=</a>( myPT &amp;&amp; ) = <span class="keywordflow">default</span>;</div><div class="line">        myPT &amp; <a class="code" href="classSequence_1_1PolyTable.html#a72dc7fa01ada9d692a6a702dd688e525">operator=</a>( <a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a> &amp; ); <span class="comment">//you&#39;ll need to define this elsewhere</span></div><div class="line">        myPT &amp; <a class="code" href="classSequence_1_1PolyTable.html#a72dc7fa01ada9d692a6a702dd688e525">operator=</a>( <a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a> &amp;&amp; ); <span class="comment">//you&#39;ll need to define this elsewhere</span></div><div class="line">};</div></div><!-- fragment --><ul>
<li>Write unit tests showing that all of the above works. See the following unit tests for examples: <a class="el" href="testSimDataIO_8cc_source.html">testSimDataIO.cc</a>, <a class="el" href="PolyTableConversions_8cc_source.html">PolyTableConversions.cc</a> <a class="el" href="SimpleSNPIO_8cc_source.html">SimpleSNPIO.cc</a> <a class="el" href="PolySitesIO_8cc_source.html">PolySitesIO.cc</a></li>
</ul>
<p>An alternative approach to creating your own class is to simply read the data into two vectors:</p>
<ol type="1">
<li>A std::vector&lt;double&gt; representing the mutation positions</li>
<li>A std::vector&lt;std::string&gt; representing the haplotypes</li>
</ol>
<p>From these two containers, a programmer can construct a <a class="el" href="classSequence_1_1PolySites.html" title="Polymorphism tables for sequence data. ">Sequence::PolySites</a> using move semantics. The construction of PolyTables is covered in the next section.</p>
<h3><a class="anchor" id="polytable_construct"></a>
Constructing PolyTables</h3>
<h4><a class="anchor" id="polytable_read"></a>
From streams</h4>
<p>Most trivially, a polymorphism table may be read in via <a class="el" href="group__operators.html#gaf30c61f076078e6be679a81646e33437">Sequence::operator&gt;&gt;</a>, which redirects to <a class="el" href="classSequence_1_1PolyTable.html#a27a62e9ee28d31f4b386c79a7af167a0">Sequence::PolyTable::read</a>. For example, to read in data from a coalescent simulation that writes to stdout:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="SimData_8hpp.html">Sequence/SimData.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv ) {</div><div class="line">    <a class="code" href="classSequence_1_1SimData.html">Sequence::SimData</a> d;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (! std::cin.eof() )</div><div class="line">    {</div><div class="line">        std::cin &gt;&gt; d &gt;&gt; std::ws;</div><div class="line">        <span class="comment">//do something interesting with &quot;d&quot; here:</span></div><div class="line">    }   </div><div class="line">}</div></div><!-- fragment --><p>See the unit test <a class="el" href="testSimDataIO_8cc_source.html">testSimDataIO.cc</a> for other ways to read/write objects of type <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">Sequence::SimData</a>.</p>
<p>See the unit test <a class="el" href="PolySitesIO_8cc_source.html">PolySitesIO.cc</a> for an example using <a class="el" href="classSequence_1_1PolySites.html" title="Polymorphism tables for sequence data. ">Sequence::PolySites</a>.</p>
<h3><a class="anchor" id="polytable_move"></a>
Using move construction</h3>
<p>Let's say we have the following data in C++ containers:</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; pos = {1,2,3,4,5};</div><div class="line">std::vector&lt;std::string&gt; data = {<span class="stringliteral">&quot;AAAAA&quot;</span>,</div><div class="line">                                 <span class="stringliteral">&quot;AAGAA&quot;</span>,</div><div class="line">                                 <span class="stringliteral">&quot;CTGAA&quot;</span>,</div><div class="line">                                 <span class="stringliteral">&quot;NAACT&quot;</span>};</div><div class="line"><span class="comment">//We can construct a PolySites by moving our data: </span></div><div class="line"><a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> ps(std::move(pos),std::move(data));</div><div class="line"></div><div class="line"><span class="comment">//Now, accessing the elements of pos and data are undefined!</span></div></div><!-- fragment --><p>These move semantics allow a library user to populate vectors and then fill PolyTables with no extra copying.</p>
<p>Remember that std::move results in the source of the move being left in what may be an undefined state. Typically, the classes in namespace std will be re-assigned some sensible default. In the above example, the "pos" and "data" vectors should both be empty. You can check if that is true on your system by runnning the unit tests in <a class="el" href="PolyTableTweaking_8cc_source.html">PolyTableTweaking.cc</a>.</p>
<p>In addition to the above example, a well-defined PolyTable has a move constructor and an overload of operator= that takes an lvalue reference as an argument, <em>e.g.</em>:</p>
<div class="fragment"><div class="line"><span class="comment">//The &amp;&amp; is an lvalue reference</span></div><div class="line">myPT &amp; operator=( myPT &amp;&amp; ) = <span class="keywordflow">default</span>;</div></div><!-- fragment --><p>See the header files <a class="el" href="PolySites_8hpp.html" title="Sequence::PolySites, generates polymorphism tables from data. ">PolySites.hpp</a>, <a class="el" href="SimData_8hpp.html" title="Declaration of Sequence::SimData, a class representing polymorphism data from coalescent simulations ...">SimData.hpp</a>, and <a class="el" href="PolyTable_8hpp.html" title="Sequence::PolyTable, a virtual base class for polymorphism tables. ">PolyTable.hpp</a> for examples of declarations. The corresponding definitions are in <a class="el" href="PolySites_8cc_source.html">PolySites.cc</a>, <a class="el" href="SimData_8cc_source.html">SimData.cc</a>, and <a class="el" href="PolyTable_8cc_source.html">PolyTable.cc</a>, respectively.</p>
<h3><a class="anchor" id="polytable_access"></a>
Accessing the data</h3>
<p>The data stored in a PolyTable may be accessed in a variety of ways. The following types are relevant, and are analogs to the usual typedefs found in STL containers (click to see their documentation):</p>
<ul>
<li><a class="el" href="classSequence_1_1PolyTable.html#af3eac733ba06c44da10b04a4d72c17bd" title="non-const reference to std::string ">Sequence::PolyTable::reference</a></li>
<li><a class="el" href="classSequence_1_1PolyTable.html#adf0e3693d4e731d92fb484762ddf6449" title="const reference to std::string ">Sequence::PolyTable::const_reference</a></li>
<li><a class="el" href="classSequence_1_1PolyTable.html#a0a3c5f364c60a09446b9de27521e047b" title="The size_type for the haplotype vector. ">Sequence::PolyTable::size_type</a></li>
<li><a class="el" href="classSequence_1_1PolyTable.html#a652e0197414d2ae7b41ebdfbdf42ffa6" title="non-const iterator to the haplotypes ">Sequence::PolyTable::data_iterator</a></li>
<li><a class="el" href="classSequence_1_1PolyTable.html#ae757b9e62ff6cf277fe54406bcd17e17" title="const iterator to the haplotypes ">Sequence::PolyTable::const_data_iterator</a></li>
<li><a class="el" href="classSequence_1_1PolyTable.html#a6ba1a3d5991cffdf4b46c9bb837f46e8" title="non-const iterator to the positions ">Sequence::PolyTable::pos_iterator</a></li>
<li><a class="el" href="classSequence_1_1PolyTable.html#af16bca677823dcb09df64ad62fbab2e8" title="const iterator to the positions ">Sequence::PolyTable::const_pos_iterator</a></li>
<li><a class="el" href="classSequence_1_1PolyTable.html#a7096e7ad3abcb257a8e7ac8c28a23e5c" title="Const iterator to segregating sites Const iterator to segregating sites. The value_type of this itera...">Sequence::PolyTable::const_site_iterator</a></li>
</ul>
<p>The following member functions exist for data access:</p>
<ul>
<li>Sequence::PolyTable::operator[] returns a reference or const_reference. The data returned correspond to a std::string representing a haplotype.</li>
<li><a class="el" href="classSequence_1_1PolyTable.html#a195d5e98a644b375422da1a41c0004bc">Sequence::PolyTable::begin</a> and <a class="el" href="classSequence_1_1PolyTable.html#a1942fc6aeda603ffa5111819e6c55dc8">Sequence::PolyTable::end</a> return either <a class="el" href="classSequence_1_1PolyTable.html#ae757b9e62ff6cf277fe54406bcd17e17" title="const iterator to the haplotypes ">Sequence::PolyTable::const_data_iterator</a> or Sequence::PolyTabe::data_iterator to haplotypes, depending on the context</li>
<li><a class="el" href="classSequence_1_1PolyTable.html#af41308232e3bf800974980a47e79e3f4">Sequence::PolyTable::cbegin</a> and <a class="el" href="classSequence_1_1PolyTable.html#a237d1ce0fc2acfe4e07a1c8d5dc712ba">Sequence::PolyTable::cend</a> return <a class="el" href="classSequence_1_1PolyTable.html#ae757b9e62ff6cf277fe54406bcd17e17" title="const iterator to the haplotypes ">Sequence::PolyTable::const_data_iterator</a> to haplotypes</li>
<li><a class="el" href="classSequence_1_1PolyTable.html#aae81867f990cacbd36bce631c8c95bf3">Sequence::PolyTable::pbegin</a> and <a class="el" href="classSequence_1_1PolyTable.html#a906a808ab8ae90406a1f66fc7d38da38">Sequence::PolyTable::pend</a> return either pos_iteraor or const_pos_iterator to the mutation positions, depending on the context</li>
<li><a class="el" href="classSequence_1_1PolyTable.html#a7848589126ef34d9fe9423809c42f69a">Sequence::PolyTable::pcbegin</a> and <a class="el" href="classSequence_1_1PolyTable.html#a99a58eea86163fffa4a977b7d8fb71cd">Sequence::PolyTable::pcend</a> return const_pos_iterator to the mutation positions.</li>
<li><a class="el" href="classSequence_1_1PolyTable.html#a3cede292ef3db63044730f603b196f50">Sequence::PolyTable::sbegin</a> and <a class="el" href="classSequence_1_1PolyTable.html#a981940003dcf7a060b747ae25ab48c39">Sequence::PolyTable::send</a> return const_site_iterators</li>
<li><a class="el" href="classSequence_1_1PolyTable.html#a3e1008471cbfa57f0be78ecc678d3ab4">Sequence::PolyTable::scbegin</a> and <a class="el" href="classSequence_1_1PolyTable.html#a9ee7467f789d9b3e4cb19d7ed0ca28b2">Sequence::PolyTable::scend</a> return const_site iterators</li>
</ul>
<p>The versions with "c" in them may appear redundant, but they are used in C++11 in the context of type deduction using keywords like auto or the declytpe function.</p>
<p><b>NOTE:</b> these iterators are aliases to the underling vectors in the base class, and should be preferred. In other words, this code:</p>
<div class="fragment"><div class="line"><a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> ps;</div><div class="line"></div><div class="line">std::for_each(ps.<a class="code" href="classSequence_1_1PolyTable.html#a195d5e98a644b375422da1a41c0004bc">begin</a>(),ps.<a class="code" href="classSequence_1_1PolyTable.html#a1942fc6aeda603ffa5111819e6c55dc8">end</a>(),[](<span class="keyword">const</span> <a class="code" href="classSequence_1_1PolyTable.html#adf0e3693d4e731d92fb484762ddf6449">Sequence::PolySites::const_reference</a> &amp; __s) { std::cout &lt;&lt; __s.length() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; });</div></div><!-- fragment --><p>is better than this code:</p>
<div class="fragment"><div class="line"><a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> ps;</div><div class="line"></div><div class="line">std::for_each(ps.second.<a class="code" href="classSequence_1_1PolyTable.html#a195d5e98a644b375422da1a41c0004bc">begin</a>(),ps.second.<a class="code" href="classSequence_1_1PolyTable.html#a1942fc6aeda603ffa5111819e6c55dc8">end</a>(),[](<span class="keyword">const</span> <a class="code" href="classSequence_1_1PolyTable.html#adf0e3693d4e731d92fb484762ddf6449">Sequence::PolySites::const_reference</a> &amp; __s) { std::cout &lt;&lt; __s.length() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; });</div></div><!-- fragment --><p>The reason why will be explained in <a class="el" href="md_md_tutorial.html#polytable_csi">Iterating over sites directly</a></p>
<p>Let's look at some examples.</p>
<div class="fragment"><div class="line"><a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> p;</div><div class="line"><span class="comment">//fill p somehow...</span></div><div class="line"></div><div class="line"><span class="comment">//Write the haplotypes to stdout</span></div><div class="line"><span class="keywordflow">for</span>( <a class="code" href="classSequence_1_1PolyTable.html#a0a3c5f364c60a09446b9de27521e047b">Sequence::PolySites::size_type</a> i = 0 ; i &lt; p.<a class="code" href="classSequence_1_1PolyTable.html#a7e0ace7755fce5a2b6142bddfecb47e8">size</a>() ; ++i )</div><div class="line">{</div><div class="line">        std::cout &lt;&lt; p[i] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div></div><!-- fragment --><p>The above example shows us that <a class="el" href="classSequence_1_1PolyTable.html#a7e0ace7755fce5a2b6142bddfecb47e8">Sequence::PolyTable::size</a> exists. There is also <a class="el" href="classSequence_1_1PolyTable.html#aaa73b7bb052f882a1801a2eb4de13282">Sequence::PolyTable::empty</a>.</p>
<p>Let's do the above using iteration:</p>
<div class="fragment"><div class="line"><a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> p;</div><div class="line"><span class="comment">//fill p somehow...</span></div><div class="line"></div><div class="line"><span class="comment">//Write the haplotypes to stdout</span></div><div class="line"><span class="keywordflow">for</span>( <a class="code" href="classSequence_1_1PolyTable.html#a652e0197414d2ae7b41ebdfbdf42ffa6">Sequence::PolySites::data_iterator</a> i = p.<a class="code" href="classSequence_1_1PolyTable.html#a195d5e98a644b375422da1a41c0004bc">begin</a>() ; </div><div class="line">     i &lt; p.<a class="code" href="classSequence_1_1PolyTable.html#a1942fc6aeda603ffa5111819e6c55dc8">end</a>() ; ++i )</div><div class="line">{</div><div class="line">        <span class="comment">//i is an iterator pointing to a std::string</span></div><div class="line">        std::cout &lt;&lt; *i &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div></div><!-- fragment --><p>Because we have begin and end defined, we can use range-based for loops in C++11:</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; pos = {1,2,3,4,5};</div><div class="line">std::vector&lt;std::string&gt; data = {<span class="stringliteral">&quot;AAAAA&quot;</span>,</div><div class="line">                                 <span class="stringliteral">&quot;AAGAA&quot;</span>,</div><div class="line">                                 <span class="stringliteral">&quot;CTGAA&quot;</span>,</div><div class="line">                                 <span class="stringliteral">&quot;NAACT&quot;</span>};</div><div class="line"></div><div class="line"><a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> ps(std::move(pos),std::move(data)),ps2;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span> d : ps )</div><div class="line">{</div><div class="line">      std::cout &lt;&lt; d &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="polytable_manip"></a>
Manipulating PolyTables</h3>
<p>We can take advantage of non-const access to data in order to manipulate what is stored:</p>
<div class="fragment"><div class="line">  std::vector&lt;double&gt; pos = {1,2,3,4,5};</div><div class="line">  std::vector&lt;std::string&gt; data = {<span class="stringliteral">&quot;AAAAA&quot;</span>,</div><div class="line">                                   <span class="stringliteral">&quot;AAGAA&quot;</span>,</div><div class="line">                                   <span class="stringliteral">&quot;CTGAA&quot;</span>,</div><div class="line">                                   <span class="stringliteral">&quot;NAACT&quot;</span>};</div><div class="line"></div><div class="line">  <a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> ps(std::move(pos),std::move(data)),</div><div class="line">    ps2(ps);</div><div class="line"></div><div class="line"><span class="comment">//Make everything lower-case</span></div><div class="line"></div><div class="line">        <span class="comment">//Non-const access to the strings</span></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span> &amp; d : ps ) {</div><div class="line">        <span class="comment">//non-const access to the char within the strings</span></div><div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp; ch : d ) {</div><div class="line">        ch = std::tolower(ch);</div><div class="line">        }</div><div class="line">}</div><div class="line">    <span class="comment">//Restore it to upper-case</span></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span> &amp; d : ps ) {</div><div class="line">        <span class="keywordflow">for</span>( <span class="keyword">auto</span> &amp; ch : d ) {</div><div class="line">                ch = std::toupper(ch);</div><div class="line">        }</div><div class="line">  }</div></div><!-- fragment --><h3><a class="anchor" id="polytable_manip_builtin"></a>
Methods provided</h3>
<p>The library provides a variety of methods for doing things like removing missing data, applying frequency filters, etc. Unfortunately (for now), these functions are mixed between member functions of <a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">Sequence::PolyTable</a> and the file <a class="el" href="PolyTableFunctions_8hpp.html" title="Operations on non-const Sequence::PolyTable objects. ">PolyTableFunctions.hpp</a>. See the documentation for <a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">Sequence::PolyTable</a> and <a class="el" href="PolyTableFunctions_8hpp.html" title="Operations on non-const Sequence::PolyTable objects. ">PolyTableFunctions.hpp</a> as well as the unit test code <a class="el" href="PolyTableTweaking_8cc_source.html">PolyTableTweaking.cc</a> for usage examples. It is possible that a future release of libsequence will deprecate the member functions in favor of standalone functions.</p>
<p>A user unfamiliar with C++ may think that many features are missing. How does one permute site positions or the order of the haplotypes? How can you remove a single haplotype? These functions are not necessary as they are possible because of the definition of <a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">Sequence::PolyTable</a> itself and the functions that already exist in the C++ Standard Template Library (STL). For example, to remove all haplotypes containing missing data, simply use the erase/remove idiom:</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; pos = {1,2,3,4,5};</div><div class="line">std::vector&lt;std::string&gt; data = {<span class="stringliteral">&quot;AAAAA&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;AAGAA&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;CTGAA&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;NAACT&quot;</span>}; <span class="comment">//This sequence will get erased below</span></div><div class="line"></div><div class="line"><a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> ps(std::move(pos),std::move(data));</div><div class="line">ps.second.erase( std::remove_if(ps.begin(),</div><div class="line">        ps.end(),</div><div class="line">                [](<span class="keyword">const</span> std::string &amp; __s) {</div><div class="line">                        <span class="keywordflow">return</span> __s.find(<span class="charliteral">&#39;N&#39;</span>) != std::string::npos;</div><div class="line">        }),</div><div class="line">        ps.end() );</div></div><!-- fragment --><p>Similarly, one may permute the haplotype order and/or the site positions using std::random_shuffle. If you are not familiar with what is in the STL, it would be a good idea to learn more about it. I quite like <a href="http://en.cppreference.com/w/">cppreference</a> as an online source.</p>
<h4><a class="anchor" id="polytable_idiot"></a>
Don't be this guy</h4>
<p>Because you have non-const access to the data, you can do this:</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; pos = {1,2,3,4,5};</div><div class="line">std::vector&lt;std::string&gt; data = {<span class="stringliteral">&quot;AAAAA&quot;</span>,</div><div class="line">                                 <span class="stringliteral">&quot;AAGAA&quot;</span>,</div><div class="line">                                 <span class="stringliteral">&quot;CTGAA&quot;</span>,</div><div class="line">                                 <span class="stringliteral">&quot;NAACT&quot;</span>};</div><div class="line"></div><div class="line"><a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> ps(std::move(pos),std::move(data)),ps2;</div><div class="line"></div><div class="line"><span class="comment">//You now have a table with unequal haplotype lengths</span></div><div class="line"><span class="comment">//This is bad, and is user error.</span></div><div class="line">ps[0] = std::string(<span class="stringliteral">&quot;A&quot;</span>);</div></div><!-- fragment --><h3><a class="anchor" id="polytable_csi"></a>
Iterating over sites directly</h3>
<p>The examples above iterate over haplotypes. It is sometimes useful to iterate over the variable sites themselves. However, iterating over site positions using <a class="el" href="classSequence_1_1PolyTable.html#aae81867f990cacbd36bce631c8c95bf3">Sequence::PolyTable::pbegin</a> and <a class="el" href="classSequence_1_1PolyTable.html#a906a808ab8ae90406a1f66fc7d38da38">Sequence::PolyTable::pend</a> only gives you access to the positions, and not to the character states. The library allows const access to sites via the member functions <a class="el" href="classSequence_1_1PolyTable.html#a3cede292ef3db63044730f603b196f50">Sequence::PolyTable::sbegin</a> and <a class="el" href="classSequence_1_1PolyTable.html#a981940003dcf7a060b747ae25ab48c39">Sequence::PolyTable::send</a>, where the "s" means "site". These functions return types <a class="el" href="classSequence_1_1PolyTable.html#a7096e7ad3abcb257a8e7ac8c28a23e5c" title="Const iterator to segregating sites Const iterator to segregating sites. The value_type of this itera...">Sequence::PolyTable::const_site_iterator</a>, whose value_type is <b>const</b> <a class="el" href="namespaceSequence.html#a08841c3bd3b0999a40dfdadbee4a6b0d">Sequence::polymorphicSite</a>, which is itself a typedef for std::pair&lt; double, std::string &gt;. Let's look at an example:</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; pos = {1,2,3,4,5};</div><div class="line">std::vector&lt;std::string&gt; data =</div><div class="line">        {<span class="stringliteral">&quot;AAAAA&quot;</span>,</div><div class="line">         <span class="stringliteral">&quot;AAGAA&quot;</span>,</div><div class="line">     <span class="stringliteral">&quot;CTGAA&quot;</span>,</div><div class="line">         <span class="stringliteral">&quot;NAACT&quot;</span>};</div><div class="line"></div><div class="line"><a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> ps(std::move(pos),std::move(data));</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">The output of this block will be:</span></div><div class="line"><span class="comment">1 AACN</span></div><div class="line"><span class="comment">2 AATA</span></div><div class="line"><span class="comment">3 AGGA</span></div><div class="line"><span class="comment">4 AAAC</span></div><div class="line"><span class="comment">5 AAAT</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span> i = ps.sbegin() ; i &lt; ps.send() ; ++i )</div><div class="line">{</div><div class="line">std::cout &lt;&lt; i-&gt;first &lt;&lt; <span class="charliteral">&#39; &#39;</span></div><div class="line">        &lt;&lt; i-&gt;second &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div></div><!-- fragment --><p>Let's call this type of output "rotated", in the sense that the sites are the rows and the haplotypes are now columns.</p>
<p>The fact that this access is const-only brings up several important points:</p>
<ol type="1">
<li><a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">Sequence::PolyTable</a> knows if you have accessed it in a const or non-const context.</li>
<li>If you access a PolyTable in a non-const context, the "rotated" representation of the data will be recalculated the next time <a class="el" href="classSequence_1_1PolyTable.html#a3cede292ef3db63044730f603b196f50">Sequence::PolyTable::sbegin</a> or <a class="el" href="classSequence_1_1PolyTable.html#a981940003dcf7a060b747ae25ab48c39">Sequence::PolyTable::send</a> is called. The reason is that your non-const access may have removed some data.</li>
<li>In the section called <a class="el" href="md_md_tutorial.html#polytable_access">Accessing the data</a>, I said that you should prefer iterator-based access to the data via the class's member functions rather than the base classes. The reason is that <em>only the former is cabable of distinguishing const from non-const access</em>, and therefore modifying the data via the latter method will result in const_site_iterators whose data are inconsistent with what the object currently stores.</li>
</ol>
<p>Let's look at a concrete example of that last point. The following example appeared above (in the section <a class="el" href="md_md_tutorial.html#polytable_manip_builtin">Methods provided</a>):</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; pos = {1,2,3,4,5};</div><div class="line">std::vector&lt;std::string&gt; data = {<span class="stringliteral">&quot;AAAAA&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;AAGAA&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;CTGAA&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;NAACT&quot;</span>}; <span class="comment">//This sequence will get erased below</span></div><div class="line"></div><div class="line"><a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> ps(std::move(pos),std::move(data));</div><div class="line">ps.second.erase( std::remove_if(ps.begin(),</div><div class="line">        ps.end(),</div><div class="line">                [](<span class="keyword">const</span> std::string &amp; __s) {</div><div class="line">                        <span class="keywordflow">return</span> __s.find(<span class="charliteral">&#39;N&#39;</span>) != std::string::npos;</div><div class="line">        }),</div><div class="line">        ps.end() );</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">The output will be:</span></div><div class="line"><span class="comment">1 AAC</span></div><div class="line"><span class="comment">2 AAT</span></div><div class="line"><span class="comment">3 AGG</span></div><div class="line"><span class="comment">4 AAA</span></div><div class="line"><span class="comment">5 AAA</span></div><div class="line"><span class="comment">*/</span></div><div class="line">std::for_each( ps.sbegin(),ps.send(),</div><div class="line">[](<span class="keyword">const</span> <a class="code" href="namespaceSequence.html#a08841c3bd3b0999a40dfdadbee4a6b0d">Sequence::polymorphicSite</a> &amp; __p) {</div><div class="line">        std::cout &lt;&lt; __p.first &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; p.second &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">});</div></div><!-- fragment --><p>However, if we had applied the erase/remove step with this code instead:</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">Here, we never call Sequence::PolyTable::begin or end.</span></div><div class="line"><span class="comment">Rather, we are calling std::vector&lt;std::string&gt;&#39;s versions</span></div><div class="line"><span class="comment">of the same functions.</span></div><div class="line"><span class="comment">Therefore, does not know that it has been accessed in</span></div><div class="line"><span class="comment">a non-const context, and calls to sbegin/send should</span></div><div class="line"><span class="comment">be viewed as leading to undefined behavior</span></div><div class="line"><span class="comment">*/</span></div><div class="line">ps.second.erase( std::remove_if(ps.second.begin(),</div><div class="line">        ps.second.end(),</div><div class="line">                [](<span class="keyword">const</span> std::string &amp; __s) {</div><div class="line">                        <span class="keywordflow">return</span> __s.find(<span class="charliteral">&#39;N&#39;</span>) != std::string::npos;</div><div class="line">        }),</div><div class="line">        ps.second.end() );</div></div><!-- fragment --><p>How does the above lead to bizarre behavior? Well, it depends:</p>
<ol type="1">
<li>If const_site_iterators have never been accessed, then the next call will regenerate the data, and all will be well.</li>
<li>If const_site_iterators <em>have</em> been previously accessed, then the above block will not signal that their data needs to be recalculated. Exactly what will happen depends on the nature of your non-const access, and should therfore be classified as "scary" at best.</li>
</ol>
<p>To see how things go badly, look at the unit test file <a class="el" href="PolyTableBadBehavior_8cc.html" title="Unit test for really bad things. ">PolyTableBadBehavior.cc</a></p>
<h2><a class="anchor" id="ptable_detail"></a>
Sequence::polySiteVector in detail</h2>
<p><a class="el" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">Sequence::polySiteVector</a> is declared in <a class="el" href="polySiteVector_8hpp.html" title="Site-major variation tables in ASCII format. ">Sequence/polySiteVector.hpp</a> and defined in <a class="el" href="polySiteVector_8cc_source.html">polySiteVector.cc</a>. From these files, you will see that this is an extremely simple class. <a class="el" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">Sequence::polySiteVector</a> is simply a std::vector&lt; Sequence::polymorphicSite &gt;, and is therefore related to the objects referred to by <a class="el" href="classSequence_1_1PolyTable.html#a7096e7ad3abcb257a8e7ac8c28a23e5c" title="Const iterator to segregating sites Const iterator to segregating sites. The value_type of this itera...">Sequence::PolyTable::const_site_iterator</a> (whose value_type is <a class="el" href="namespaceSequence.html#a08841c3bd3b0999a40dfdadbee4a6b0d">Sequence::polymorphicSite</a>).</p>
<p>This class is most powerful in light of C++11's addition of lambda expressions to the language. The definition of <a class="el" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">Sequence::polySiteVector</a> plus the power of lambda expressions leads to a very powerful grammer for manipulating variation tables. For example, let is remove all sites with invalid characters (as defined in <a class="el" href="md_md_tutorial.html#polytable_terms">Definitions of terms</a>) from a polySiteVector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> psite = <a class="code" href="namespaceSequence.html#a08841c3bd3b0999a40dfdadbee4a6b0d">Sequence::polymorphicSite</a>;</div><div class="line"><a class="code" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">Sequence::polySiteVector</a> t = { psite(1.,<span class="stringliteral">&quot;AAGC&quot;</span>),</div><div class="line">                       psite(2.,<span class="stringliteral">&quot;ACZA&quot;</span>) }; <span class="comment">//site 2 has a non-DNA character</span></div><div class="line"></div><div class="line">      <span class="comment">//This will remove site 2:</span></div><div class="line">t.erase( std::remove_if( t.begin(),</div><div class="line">                      t.end(),</div><div class="line">                      []( <span class="keyword">const</span> psite &amp; __p ) {</div><div class="line">                           <span class="keywordflow">return</span> std::find_if(__p.second.begin(),</div><div class="line">                                               __p.second.end(),</div><div class="line">                                               <a class="code" href="structSequence_1_1invalidPolyChar.html">Sequence::invalidPolyChar</a>())</div><div class="line">                             != __p.second.end();</div><div class="line">                         } ),</div><div class="line">         t.end() );</div></div><!-- fragment --><p>The syntax in the above example is compact, readable, efficient, and avoids the pre-C++11 headache of having to define standalone function objects for such simple tasks. The above code block is from the unit test file <a class="el" href="polySiteVectorTest_8cc.html" title="Unit tests for Sequence::polySiteVector. ">polySiteVectorTest.cc</a>. See the example program <a class="el" href="polySiteVector__test_8cc.html" title="Examples of using Sequence::polySiteVector. ">polySiteVector_test.cc</a> for some cool usage cases.</p>
<h2><a class="anchor" id="polytable_ptable"></a>
The relationship between PolyTable and polySiteVector</h2>
<p>These two types are intimately-related and may be constructed from one another.</p>
<h2><a class="anchor" id="polytable_ptable"></a>
The relationship between PolyTable and polySiteVector</h2>
<h1><a class="anchor" id="summstats"></a>
Summary statistics</h1>
<h2><a class="anchor" id="classic"></a>
Standard summary statistics</h2>
<p>libsequence contains routines for calculating several standard summary statistics (Watterson's <img class="formulaInl" alt="$\theta$" src="form_0.png"/>, Tajima's <img class="formulaInl" alt="$\pi$" src="form_1.png"/>, etc.). The relevant classes are:</p>
<ul>
<li><a class="el" href="classSequence_1_1PolySNP.html" title="Molecular population genetic analysis. ">Sequence::PolySNP</a> to calculate statistics from nucleotide data. The allowed character set is A,G,C,T,N,-.</li>
<li><a class="el" href="classSequence_1_1PolySIM.html" title="Analysis of coalescent simulation data. ">Sequence::PolySIM</a> inherits from PolySNP and is intended to be used with biallelic data encoded in a 0/1 format where 0 = ancestral and 1 = the derived character state. This class is tightly-coupled to <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">Sequence::SimData</a>. See the example program <a class="el" href="msstats_8cc_source.html">msstats.cc</a> for how to use this class.</li>
</ul>
<p>These classes are constructed from objects in the <a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">Sequence::PolyTable</a> class hierarchy:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="PolySNP_8hpp.html">Sequence/PolySNP.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="PolySites_8hpp.html">Sequence/PolySites.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line">std::vector&lt;double&gt; pos = {1,2,3,4,5};</div><div class="line">std::vector&lt;std::string&gt; data = {<span class="stringliteral">&quot;AAAAA&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;AAGAA&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;CTGAA&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;NAACT&quot;</span>}; </div><div class="line"></div><div class="line"><a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> ps(std::move(pos),std::move(data));</div><div class="line"></div><div class="line"><a class="code" href="classSequence_1_1PolySNP.html">Sequence::PolySNP</a> aps(&amp;ps);</div><div class="line"></div><div class="line"><span class="comment">//Now, output some summary stats</span></div><div class="line">std::cout &lt;&lt; aps.NumPoly() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Number of segregating sites</span></div><div class="line">        &lt;&lt; aps.ThetaW() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Watterson&#39;s theta</span></div><div class="line">        &lt;&lt; aps.ThetaPi() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Tajima&#39;s pi</span></div><div class="line">        &lt;&lt; aps.TajimasD() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">//Tajima&#39;s D</span></div></div><!-- fragment --><p>Take a look at the class documentation for <a class="el" href="classSequence_1_1PolySNP.html" title="Molecular population genetic analysis. ">Sequence::PolySNP</a> and <a class="el" href="classSequence_1_1PolySIM.html" title="Analysis of coalescent simulation data. ">Sequence::PolySIM</a> for a list of all the things that you can calculate from a PolyTable &ndash; there is a lot there.</p>
<h2><a class="anchor" id="classic_fst"></a>
FST</h2>
<p>The class <a class="el" href="classSequence_1_1FST.html" title="analysis of population structure using  ">Sequence::FST</a> allows the calculation of <img class="formulaInl" alt="$F_{st}$" src="form_2.png"/> statistics from PolyTables + a vector of the sample sizes per population:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="PolySites_8hpp.html">Sequence/PolySites.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="FST_8hpp.html">Sequence/FST.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line">std::vector&lt;double&gt; pos = {1,2,3,4,5};</div><div class="line">std::vector&lt;std::string&gt; data = {<span class="stringliteral">&quot;AAAAA&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;AAGAA&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;CTGAA&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;CAACT&quot;</span>};</div><div class="line"><span class="comment">//The sample size is 2 in each subpop:</span></div><div class="line">std::vector&lt;unsigned&gt; sample_sizes = {2,2};</div><div class="line"><a class="code" href="namespaceSequence.html">Sequence</a> FST fst_calculator(&amp;data,sample_sizes.size(),&amp;sample_sizes[0]);</div><div class="line">std::cout &lt;&lt; fst_calculator.HSM() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Hudson, Slaktin, Maddison</span></div><div class="line">        &lt;&lt; fst_calculator.HBK() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Hudson, Boos, Kaplan</span></div><div class="line">        &lt;&lt; fst_calculator.Slatkin() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span>  <span class="comment">//Slatkin</span></div><div class="line">        <span class="comment">//below are the components of Fst calculations:</span></div><div class="line">        &lt;&lt; fst_calculator.piB() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Mean pairwise divergence b/w pops</span></div><div class="line">        &lt;&lt; fst_calculator.piT() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Total diversity</span></div><div class="line">        &lt;&lt; fst_calculator.piS() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//mean within-pop diversity</span></div><div class="line">        &lt;&lt; fst_calculator.piD() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;<span class="comment">//The difference between- and within- pop diversity</span></div></div><!-- fragment --><h2><a class="anchor" id="hka"></a>
The HKA test</h2>
<p>The HKA test statistic is available via the functions <a class="el" href="group__popgen.html#ga490ad3c8b4e548d1cf850806b6a5be1d">Sequence::calcHKA</a>.</p>
<h2><a class="anchor" id="stat_future"></a>
The future</h2>
<p><a class="el" href="classSequence_1_1PolySNP.html" title="Molecular population genetic analysis. ">Sequence::PolySNP</a> and <a class="el" href="classSequence_1_1PolySIM.html" title="Analysis of coalescent simulation data. ">Sequence::PolySIM</a> are "factory" objects, which means that they pre-process your data and contain lots of member functions to calculate various statistics. A significant problem with this design is that adding new summary statistics breaks the library's compatibility with existing programs compiled against it (because the sizeof(Sequence::PolySNP) changes with the addition of new funtions). The future of libsequence's interface to summary statistics will be:</p>
<ul>
<li>Extracting the preprocessing steps from <a class="el" href="classSequence_1_1PolySNP.html" title="Molecular population genetic analysis. ">Sequence::PolySNP</a> to a standalone class</li>
<li>Rewriting the summary statistic calculations as standalone functions taking the preprocessed data object as a parameter.</li>
</ul>
<p>The interface described above will be kept because there is a lot of code sitting around that depends upon it.</p>
<h1><a class="anchor" id="coalsim"></a>
Coalescent simulation</h1>
<p>The sub-namespace <a class="el" href="namespaceSequence_1_1coalsim.html" title="Routines for coalescent simulation. ">Sequence::coalsim</a> contains the routines required for implementing coalescent simulations with recombination using Hudson's algorithm (e.g., the one that underlies his <a href="http://www.ncbi.nlm.nih.gov/pubmed/11847089">ms</a> program, <a class="el" href="citelist.html#CITEREF_Hudson:2002vy">[2]</a>). A full introduction to these routines is beyond the scope of this document at the moment, but the namespace has the following features:</p>
<ul>
<li>There are no global variables representing the fundamental data structures. Thus, the code base is prone to fewer side-effects than one would encounter in modifying ms directly.</li>
<li>It is agnostic with respect to time scale, and may be used for discrete or continuous time scales at the user's discretion</li>
<li>The current implementation has the Kingman coalescent in mind, in which all coalsecent events are between pairs of lineages. However, the fundamental data structure (<a class="el" href="structSequence_1_1coalsim_1_1marginal.html" title="The genealogy of a portion of a chromosome on which no recombination has occurred. ">Sequence::coalsim::marginal</a>) will also be compatible with simulating "lamba" coalescents.</li>
<li>The recombination method implemented in <a class="el" href="group__coalescent.html#ga9b2ec8b27b3800757f2e360f6c000499" title="Recombination function. ">Sequence::coalsim::crossover</a> is Hudson's algorithm. There is currently no support for the Markovian approximation to this process, but there could be in the future.</li>
<li>The namespace uses templates to achieve independence from any particular random number generation system. I have successfully used it with both the C++11 &lt;random&gt; header and the <a href="http://gnu.org/software/gsl">GSL</a> functions.</li>
</ul>
<p>The namespace implements several standard/simple demographic scenarios in the file <a class="el" href="DemographicModels_8hpp_source.html">Sequence/Coalescent/DemographicModels.hpp</a>.</p>
<p>The following example programs show more complex use scenarios:</p>
<ul>
<li><a class="el" href="msmm_8cc_source.html">msmm.cc</a></li>
<li><a class="el" href="freerec_8cc_source.html">freerec.cc</a></li>
<li><a class="el" href="fragments_8cc_source.html">fragments.cc</a></li>
<li><a class="el" href="bottleneck_8cc_source.html">bottleneck.cc</a></li>
</ul>
<p>There is support for simulation involving selection via the header <a class="el" href="Trajectories_8hpp_source.html">Sequence/Coalescent/Trajectories.hpp</a>.</p>
<p><b>DISCLAIMER:</b> Please note that this namespace may easily lead to having "too much rope". As with any simulation interface, knowing how to test what you've coded up is critical, and these functions are intended for people who are comfortable with coalescent theory.</p>
<h1><a class="anchor" id="hts_tut"></a>
High-throughput sequencing</h1>
<h2><a class="anchor" id="sam"></a>
SAM records</h2>
<p>The class <a class="el" href="classSequence_1_1samrecord.html" title="A single alignment record from a SAM file. ">Sequence::samrecord</a> allows processing SAM records from streams:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="samrecord_8hpp.html">Sequence/samrecord.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="classSequence_1_1samrecord.html">Sequence::samrecord</a> r;</div><div class="line"></div><div class="line"><span class="keywordflow">while</span>( ! std::cin.eof() )</div><div class="line">{</div><div class="line">        std::cin &gt;&gt; r &gt;&gt; std::ws;</div><div class="line">}</div></div><!-- fragment --><p>Intended usage for a program using this class would be:</p>
<div class="fragment"><div class="line">samtools view bamfile | ./program</div></div><!-- fragment --><p>The class provides no method for parsing a SAM header. However, doing so is trivial, and is left to the library user</p>
<h2><a class="anchor" id="samflags"></a>
SAM flags and bit fields</h2>
<p>SAM/BAM data contain "SAM flag" fields. These fields are 32-bit integers containing a lot of info about the alignment. They are represented in libsequence by <a class="el" href="classSequence_1_1samflag.html" title="The flag field of a SAM record. ">Sequence::samflag</a>. This type contains boolean variables (<a class="el" href="classSequence_1_1samflag.html#af831de6c7940e6a2ea642f5dad6ba3be">Sequence::samflag::is_paired</a>, etc.) representing the various data fields. The parsing of the bit fields is implemented using data in namespace <a class="el" href="namespaceSequence_1_1sambits.html" title="Stores the hex flags used by a SAM file flag field in an easy-to-read format. ">Sequence::sambits</a>.</p>
<h2><a class="anchor" id="bam"></a>
BAM files</h2>
<p><a class="el" href="classSequence_1_1bamreader.html" title="A class managing input from BAM files. ">Sequence::bamreader</a> allows reading directly from BAM files. The class also supports seeking within a BAM file. An alignment is represented by <a class="el" href="classSequence_1_1bamrecord.html" title="A single alignment record from a BAM file. ">Sequence::bamrecord</a>, and is returned from a bamreader via <a class="el" href="classSequence_1_1bamreader.html#a0da56453c04e9c1128a6010b775db324">Sequence::bamreader::next_record</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bamreader_8hpp.html">Sequence/bamreader.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">        The header is now parsed if the file was opened successfully</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><a class="code" href="classSequence_1_1bamreader.html">Sequence::bamreader</a> r(<span class="stringliteral">&quot;file.bam&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ( r )</div><div class="line">{</div><div class="line">        <span class="keywordflow">while</span>( !r.eof() &amp;&amp; !r.error() )</div><div class="line">        {</div><div class="line">                <a class="code" href="classSequence_1_1bamrecord.html">Sequence::bamrecord</a> rec = r.next_record();</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>You may access the BAM header info via:</p>
<ul>
<li><a class="el" href="classSequence_1_1bamreader.html#abc2b9b9615104fcc80390f53366a485e">Sequence::bamreader::header</a></li>
<li>Sequence::bamreader::operator[]</li>
<li><a class="el" href="classSequence_1_1bamreader.html#ab29eeb751431e05d5975ada122d45ac5">Sequence::bamreader::ref_cbegin()</a></li>
<li><a class="el" href="classSequence_1_1bamreader.html#af7edceaeb0b9d8ddbf3ec5ce3c2626d2">Sequence::bamreader::ref_cend()</a></li>
</ul>
<p>And use <a class="el" href="classSequence_1_1bamreader.html#a762097fea4c36f9cee62bab0cbd6475a">Sequence::bamreader::n_ref</a> to get the number of sequences in the reference.</p>
<p>The <a class="el" href="classSequence_1_1bamrecord.html" title="A single alignment record from a BAM file. ">Sequence::bamrecord</a> class provides a set of functions to get at the alignment data. These are direct representations of how the BAM data are stored. See the class documentation for details.</p>
<p>Some comments:</p>
<ul>
<li><a class="el" href="classSequence_1_1bamreader.html" title="A class managing input from BAM files. ">Sequence::bamreader</a> is based on the BAM specification. <a href="http://htslib.org">htslib</a> is not used for anything other than bgzf decompression and seeking.</li>
<li><a class="el" href="classSequence_1_1bamrecord.html" title="A single alignment record from a BAM file. ">Sequence::bamrecord</a> is move-constructable, meaning that it is lightning fast to copy alignments into containers, etc.</li>
</ul>
<p>See the author's <a href="http://github.com/molpopgen/pecnv">pecnv</a> for real-world use of theses classes. Those programs scan large BAM files in minutes using these classes. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 16 2017 17:01:27 for libsequence by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
